use hex::FromHex;
use rlp::RlpStream;
use serde::{Deserialize, Deserializer};
use crate::{EthProver};

//#[macro_use]
//extern crate lazy_static;
use lazy_static::lazy_static;

#[derive(Debug)]
struct Hex(pub Vec<u8>);

impl<'de> Deserialize<'de> for Hex {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        let mut s = <String as Deserialize>::deserialize(deserializer)?;
        if s.starts_with("0x") {
            s = s[2..].to_string();
        }
        if s.len() % 2 == 1 {
            s.insert_str(0, "0");
        }
        Ok(Hex(Vec::from_hex(&s).map_err(|err| {
            serde::de::Error::custom(err.to_string())
        })?))
    }
}

// TESTS

use near_bindgen::MockedBlockchain;
use near_bindgen::{testing_env, VMContext};

lazy_static! {
    static ref WEB3RS: web3::Web3<web3::transports::Http> = {
        let (eloop, transport) = web3::transports::Http::new(
            "https://mainnet.infura.io/v3/b5f870422ee5454fb11937e947154cd2",
        )
        .unwrap();
        eloop.into_remote();
        web3::Web3::new(transport)
    };
}

fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
    VMContext {
        current_account_id: "alice.near".to_string(),
        signer_account_id: "bob.near".to_string(),
        signer_account_pk: vec![0, 1, 2],
        predecessor_account_id: "carol.near".to_string(),
        input,
        block_index: 0,
        block_timestamp: 0,
        account_balance: 0,
        account_locked_balance: 0,
        storage_usage: 0,
        attached_deposit: 0,
        prepaid_gas: 10u64.pow(18),
        random_seed: vec![0, 1, 2],
        is_view,
        output_data_receivers: vec![],
    }
}

#[test]
fn simple_tx_res() {
    testing_env!(get_context(vec![], false));

    let contract = EthProver::init("ethbridge".to_string());

    let log_index = 0;
    let receipt_index = 0;
    let header_data = Vec::from_hex("f901f6a0b6966db1bf256e1943edab70d368950904ac5b54e46801bbf3b00e07a1a24210a01dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347940000000000000000000000000000000000000000a0f174e800bac63e98447a7aa0d68dd983837ccf38d124450c8060e1d90da15066a088ce77ae7b5397b5d679148424f8d6c6e715feb4f5b206132f6092ad896bf23da0f11406c226b6d85d0d437a2c85592b59cb1841d17f0c2cdd6d70e413b549c2e2b9010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000200000000000000000000000000000000000000000004000000000000000000000000020000000000000000040000000000000000000000000000000000000000000000000000000000000000000300483989680825bb0845eaacedb80a00000000000000000000000000000000000000000000000000000000000000000880000000000000000").unwrap();
    let receipt_data = Vec::from_hex("f901a601825bb0b9010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000200000000000000000000000000000000000000000004000000000000000000000000020000000000000000040000000000000000000000000000000000000000000000000000000000000000000f89df89b940f5ea0a652e851678ebf77b69484bfcd31f9459bf842a000032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0a00000000000000000000000000000000000000000000000000000000000000001b84000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003").unwrap();
    let log_entry = Vec::from_hex("f89b940f5ea0a652e851678ebf77b69484bfcd31f9459bf842a000032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0a00000000000000000000000000000000000000000000000000000000000000001b84000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003").unwrap();
    let proof = vec![
        Vec::from_hex("2080").unwrap(),
        Vec::from_hex("f901a601825bb0b9010000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000200000000000000000000000000000000000000000004000000000000000000000000020000000000000000040000000000000000000000000000000000000000000000000000000000000000000f89df89b940f5ea0a652e851678ebf77b69484bfcd31f9459bf842a000032a912636b05d31af43f00b91359ddcfddebcffa7c15470a13ba1992e10f0a00000000000000000000000000000000000000000000000000000000000000001b84000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003").unwrap(),
    ];

    let mut stream = RlpStream::new();
    stream.begin_list(proof.len());
    for item in proof {
        stream.append(&item);
    }

    assert!(contract.verify_log_entry(
        log_index,
        log_entry,
        receipt_index,
        receipt_data,
        header_data,
        vec![stream.out()],
        true
    ));
}
